1. ==: 既可以判断基本类型(值是否相等)，又可以判断引用类型(判断的是地址是否相等) 。equals 默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。

2. 基本数据类型，传递的是值(值拷贝)，形参的任何改变不影响实参。引用类型传递的是地址，可以通过形参影响实参，栈的值是地址，改的时候修改的是对应堆中的值。

3. 将实参传递给方法（或函数）的方式是拷贝传递：如果参数是基本类型的话，传递的就是基本类型的字面量值的拷贝,在栈中创建副本指向这个新的拷贝值。 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，会创建副本指向原地址。 因此，在递归方法调用的时候，如果方法中使用的是引用类型变量(比如数组，对象)，就会共享该引用类型的数据。

4. 构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。构造方法名和类名相同，在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。一旦定义了自己的构造器, 默认的构造器就被覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下,即:Dog(){}

5. java虚拟机会给每个对象分配 this, 代表当前对象。this.name 就是当前对象的属性name。this 关键字可以用来访问本类的属性、方法、构造器， 用于区分当前类的属性和局部变量。访问构造器语法：this(参数列表); 只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一条语句)。

6. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过。super 在使用时，必须放在构造器第一行( super 只能在构造器中使用)。super() 和this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器。如果多个基类(上级类)中都有同名的成员，使用super访问遵循就近原则。

7. 同一个类中方法一样的是重载， 父子类中方法一样的是重写。子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类。子类方法不能缩小父类方法的访问权限。

8. 编译类型在定义对象时，就确定了，不能改变。运行类型是可以变化的。多态的前提是：两个对象(类)存在继承关系。向上转型： 父类的引用指向了子类的对象，父类类型引用名=new子类类型()。向下转型：子类类型 引用名 = (子类类型) 父类引用， 只能强转父类的引用，不能强转父类的对象。属性的值看编译类型。

9. 静态方法（类方法）的调用：类名.类方法名 或者 对象名.类方法名。当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法, 提高开发效率。工具类中的方法utils。Math类、Arrays类、Collections集合类看下源码可以发现都是static方法。类方法(静态方法)中只能访问静态变量或静态方法。

10. 代码块修饰符可选,要写的话,也只能写static。相当于另外一种形式的构造器(对构造器的补充机制)，可以做初始化的操作。代码块调用的顺序优先于构造器。

11. 创建一个对象时，在一个类调用顺序是∶

    1. 调用静态代码块和静态属性初始化 (注意:静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的先后顺序调用)
    2. 调用普通代码块和普通属性的初始化(注意:普通代码块和普通属性初始化调用的优先级一样,如果有多个普通代码块和多个普通属性初始化,则按定义先后顺序调用)
    3. 调用构造方法

12. 创建一个子类对象时(继承关系)，他们的调用顺序如下:

    1. 父类的静态代码块和静态属性(优先级一样,按定义顺序执行)（类加载）
    2. 子类的静态代码块和静态属性(优先级一样,按定义顺序执行)（类加载）
    3. 父类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)
    4. 父类的构造方法
    5. 子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)
    6. 子类的构造方法

13. 单例模式之饿汉式：构造器私有化 =》防止直接new， 类的内部创建对象，向外暴露一个静态的公共方法 getlnstance。 在线程还没出现之前就已经实例化了,因此饿汉式线程一定是安全的。单例模式之懒汉式: 只有當用戶使用getInstance時，才返回cat對象, 後面再次調用時，會返回上次創建的cat對象。可能会存在线程安全的问题。

14. final不能修饰构造方法(即构造器)。因为构造器的作用是创建对象，在对象创建时，需要对对象的成员变量进行初始化。因此构造器的执行过程是不可变的，不能被覆盖或修改。将构造器声明为final没有实际意义，也不符合构造器的使用目的。

15. final 和 static 往往搭配使用，效率更高。final修饰的变量是常量，编译器在编译时会将这些常量直接替换为它们的值，从而减少运行时的计算开销。而static关键字使得变量或方法属于类本身而不是类的实例，从而避免了不必要的对象创建 。当它们修饰同一个类的属性时，调用该属性并不会导致类的加载。这样在运行时不仅提高了访问速度，也减少了内存消耗和类加载的频率 。

16. 抽象类不能被实例化, 一旦类包含了abstract方法,则这个类必须声明为abstract。抽象方法不能有主体，即不能实现。如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。抽象方法不能使用private、final和 static来修饰，因为这些关键字都是和重写相违背的。

17. 接口是更加抽象的类。Jdk8.0后接口类可以有静态方法（static），默认方法（default），也就是说接口中可以有方法的具体实现。接口不能被实例化，接口中所有的方法是public方法，接口中抽象方法，可以不用abstract修饰。一个普通类实现接口,就必须将该接口的所有方法都实现。抽象类实现接口，可以不用实现接口的方法。一个类同时可以实现多个接口。接口中的属性，只能是final的，而且是 public static final修饰符。接口不能继承类,但是可以继承多个别的接口。

18. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问。

19. 匿名内部类是定义在外部类的局部位置, 比如方法中, 并且没有类名，同时还是一个对象。编译类型是一个接口或者类，运行类型是匿名内部类，直接创建一个实例，IA tiger = new IA(){}。可以直接访问外部类的所有成员，包含私有的。如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则,如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问。应用场景：当做实参直接传递，简洁高效。

20. 对枚举对象/属性使用 final + static共同修饰，实现底层优化, 不需要提供setXxx方法，因为枚举对象值通常为只读。

21. try-catch：如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块。可以有多个catch语句，捕获不同的异常(进行不同的业务处理)，要求父类异 常在后，子类异常在前。如果发生异常，只会匹配一个catch。try-finally 这种用法相当于没有捕获异常，finally 执行完直接退出。

22. 子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型。子类有一个编译异常，使用throws抛出，那么父类也必须对该异常做出反应，或是throws，或者try catch，否则同样是编译异常。

23. 继承Exception，属于编译异常; 继承RuntimeException，属于运行异常。一般情况下，我们自定义异常是继承 RuntimeException, 好处是我们可以使用默认的处理机制，即自动向上throws异常，否则main中也得加throws。

24. 创建String 对象的两种方式: 方式一: 直接赋值String s = "hspedu" (自动封箱，指向常量池的空间地址); 方式二: 调用构造器 String s = new String("hspedu"，指向堆中空间地址);String是一个final类，一个字符串对象一旦被分配，其内容是不可变的。String c1 = "ab" + "cd";常量相加，看的是池。String c1 = a+b;变量相加,是在堆中。

25. 因为StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String。

26. StringBuilder不是线程安全,该类被设计用作 StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类。因为在大多数实现中，它比 StringBuffer 要快。

27. 集合主要是两组(单列集合, 双列集合), Collection 接口有两个重要的子接口List Set , 他们的实现子类都是单列集合 （单列数据）。Map 接口的实现子类是双列集合，存放的K-V （双列数据）。Collection遍历方式， 迭代器和增强for。Iterator 本身并不存放对象。（import java.util.Iterator; Iterator iterator = col.iterator();）。Collections 工具类： Collections是一个操作 Set、List 和 Map等集合的工具类。

28. List集合中的每个元素都有其对应的顺序索引，即支持索引。ArrayList：基于动态数组实现，支持快速随机访问，但插入和删除操作较慢，因为需要移动大量元素。LinkedList：基于双向链表实现，随机访问效率低，但插入和删除操作效率高，不需要移动其他元素，线程不安全，没有实现同步。Vector：与ArrayList类似，也是基于动态数组实现，但所有操作都是线程安全的

29. Set 接口：无序（添加和取出的顺序不一致，但是顺序固定)，没有索引； HashSet实现了Set接口, 实际上是HashMap。添加一个元素时，先得到hash值-会转成->索引值， 找到存储数据表table，看这个索引位置是否已经存放的有元素， 如果有，调用equals比较，如果相同，就放弃添加。如果不相同，则添加到最后。 如果一条链表的元素个数到达 TREEIFY_THRESHOLD(默认是8)，并且table的大小>=MIN TREEIFY CAPACITY(默认64),就会进行树化(红黑树)，否则仍然会采用数组扩容机制。LinkedHashSet 是 HashSet的子类, LinkedHashSet 底层是一个 LinkedHashMap，底层维护了一个数组+双向链表，能确保插入顺序和遍历顺序一致。

30. Map 接口: 遍历方式（map.keySet()；  keyset.iterator()；Collection values = map.values();   map.entrySet(); ）Map接口的常用实现类:HashMap、Hashtable和Properties。HashMap没有实现同步，因此是线程不安全的,方法没有做同步互斥的操作,没有synchronized。hashTable是线程安全的(synchronized)。Properties类继承自 Hashtable 类并且实现了Map接口。

31. 泛型：传统ArrayList不能对加入到集合ArrayList中的数据类型进行约束，遍历的时候，需要进行类型转换,如果集合中的数据量较大，对效率有影响。泛型只能是引用类型。使用泛型的数组，不能初始化，静态方法中不能使用类的泛型否则JVM就无法完成初始化。自定义泛型接口： 泛型接口的类型,在继承接口或者实现接口时确定。泛型不具备继承性，支持A类以及A类的子类，规定了泛型的上限，支持A类以及A类的父类，不限于直接父类，规定了泛型的下限。

32. 线程由进程创建的，是进程的一个实体，一个进程可以拥有多个线程。并发:同一个时刻，多个任务交替执行，造成一种“貌似同时”的错觉，简单的说单核cpu实现的多任务就是并发。并行:同一个时刻，多个任务同时执行。多核cpu可以实现并行。使用有两种方法： 继承Thread类，重写run方法； 实现Runnable接口,重写run方法（防止只能单一继承）。

33. 当main线程启动一个子线程 Thread-0, 主线程不会阻塞, 会继续执行（不会等执行完毕后再往下执行），这时 主线程和子线程是交替执行。start底层会创建新的线程，调用run, run 就是一个简单的方法调用，不会启动新线程。yield：线程的礼让。让出cpu,让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功。join：线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务。

34. 将一个线程设置成守护线程：只需要将 `myDaemonThread.setDaemon(true);` 设置为 `true` 即可。守护线程: 一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束。

35. 线程同步机制: 线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作。1. Synchronized: 同步代码块 或 方法声明， 但导致程序的执行效率要降低。。2. 互斥锁：关键字synchronized来与对象的互斥锁联系。

36. IO 流的分类：按操作数据单位分为字节流(8 bit)（二进制文件例如声音视频word等可以无损操作），字符流(按字符)（文本文件）。按流的角色的不同分为：节点流，处理流 / 包装流。字节流 ： FileInputStream / FileOutputStream； 字符流：FileReader / FileWriter 。节点流可以从一个特定的数据源读写数据，如FileReader、FileWriter， 底层流/低级流,直接跟数据源相接。 FileWriter使用后，必须要关闭(close)或刷新(flush)，否则写入不到指定的文件，因为仅仅到了Java程序内存中。

37. 处理流(也叫包装流)是“连接”在已存在的流（节点流或处理流)之上，为程序提供更为强大的读写功能，也更加灵活,如BufferedReader、BufferedWriter， 对节点流进行包装，使用了修饰器设计模式， 不会直接与数据源相连，关闭时关闭外层的处理流即可，底层会去关闭节点流。处理流的功能：性能的提高:主要以增加缓冲的方式来提高输入输出的效率。操作的便捷:处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据,使用更加灵活方便。BufferedOutputStream是字节流, 实现缓冲的输出流, 可以将多个字节写入底层输出流中，而不必对每次字节写入调用底层系统。

38. 对象流ObjectInputStream 和ObjectOutputStream：：不仅保存值，还保存数据类型，能够将基本数据类型或者对象进行序列化和反序列化操作。序列化就是在保存数据时，保存数据的值和数据类型，反序列化就是在恢复数据时，恢复数据的值和数据类型。必须实现如下两个接口之一: Serializable （一个标记接口,没有方法）； Externalizable （该接口有方法需要实现，比较少用）。序列化的类中建议添加SerialVersionUID，为了提高版本的兼容性。当加入新属性时，序列化和反序列化会认为是原来的修改版，而不会认为是一个全新的类。序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员。也就是序列化并不保存`static`或`transient`修饰的信息。序列化对象时，要求里面属性的类型也需要实现序列化接口。序列化具备可继承性，也就是如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化。

39. 转换流InputStreamReader 和OutputStreamWriter： 当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文 问题,所以建议将字节流转换成字符流。可以在使用时指定编码格式(比如utf-8, gbk , gb2312,ISO8859-1等)

40. TCP 网络通信编程： Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。网络通信其实就是Socket间的通信。最后需要关闭流对象、socket、serverSocket，不然链接太多会出现问题。 serverSocket 可以通过 accept() 返回多个Socket[多个客户端连接服务器的并发]

41. UDP 网络通信编程：类 `DatagramSocket` 和 `DatagramPacket`[数据包/数据报]实现了基于UDP 协议网络程序。`DatagramPacket` 对象封装了UDP数据报，在数据报中包含了发送端的IP地址和 端口号以及接收端的IP地址和端口号。UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方 的连接。基本流程

    1. 核心的两个类/对象 DatagramSocket与DatagramPacket
    2. 建立发送端，接收端(没有服务端和客户端概念)
    3. 发送数据前,建立数据包/报 DatagramPacket对象
    4. 调用DatagramSocket发送。接收方法, 将通过网络传输的 DatagramPacket 对象//填充到 packet对象
    5. 关闭DatagramSocket

42. 反射(reflection)： 反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载。通过外部文件配置，在不修改源码情况下来控制程序。优点:可以动态的创建和使用对象(也是框架底层核心),使用灵活,没有反射机制,框架技术就失去底层支撑。缺点:使用反射基本是解释执行,对执行速度有影响。在反射中，可以把方法视为对象（万物皆对象），允许程序在执行期借助于 `Reflection API` 取得任何类的内部信息(比如成员变量，构造器，成员方法等等)，并能操作对象的属性及方法，生成动态代理。对于某个类的Class类对象,在内存中只有一份，因为类只加载一次，Class对象是存放在堆的。

    1. java.lang.Class:代表一个类，Class对象表示某个类加载后在堆中的对
    2. java.lang.reflect.Method:代表类的方法, Method对象表示某个类的方法
    3. java.lang.reflect.Field:代表类的成员变量,Field对象表示某个类的成员变量
    4. java.lang.reflect.Constructor:代表类的构造方法,Constructor对象表示 构造器

    ```
            //(1) 加载类, 返回Class类型的对象cls， Class类对象不是new出来的，而是系统创建的
            Class cls = Class.forName(classfullpath);
            //(2) 通过 cls 得到你加载的类 com.hspedu.Cat 的对象实例
            Object o = cls.newInstance();
            System.out.println("o的运行类型=" + o.getClass()); //运行类型
            //(3) 通过 cls 得到你加载的类 com.hspedu.Cat 的 methodName"hi"  的方法对象
            //    即：在反射中，可以把方法视为对象（万物皆对象）
            Method method1 = cls.getMethod(methodName);
            //(4) 通过method1 调用方法: 即通过方法对象来实现调用方法
            System.out.println("=============================");
            method1.invoke(o); //传统方法 对象.方法() , 反射机制 方法.invoke(对象)
    ```

43. 反射调用优化-关闭访问检查：Method 和 Field、Constructor对象都有 setAccessible() 方法。setAccessible作用是启动和禁用访问安全检查的开关。参数值为true表示反射的对象在使用时取消访问检查，提高反射的效率。参数值为false则表示反射的对象执行访问检查。

44. 如下类型有Class 对象

    1. 外部类，成员内部类，静态内部类,局部内部类，匿名内部类

    2. interface:接口

    3. 数组

    4. enum:枚举

    5. annotation:注解

    6. 基本数据类型

    7. void

       

    

    

