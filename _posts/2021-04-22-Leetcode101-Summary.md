---
title: Leetcode 101 笔记
categories: 算法模型
tags: 人间草木
description: 
comments: true
author: Tang Qi
sidebar:
  nav: docs-cn
aside:
  toc: true
layout: post
---

总结 《LeetCode 101》的关键点，便于快速回忆。


### 1. 贪心算法

基于前提：当全局结果是局部结果的简单求和，且局部结果互不相干。
核心思想：每次操作都是局部最优的，局部最优的策略也同样是全局最优的策略。
典型问题：分配问题，不重叠区间问题



### 2. 双指针

1. 同向遍历：归并有序数组、快慢指针(链表找环路)、连续子字符串
2. 反向遍历：固定和求解



### 3. 二分法

出发点：通过将待查找区间分成两部分并只取一部分继续查找，查找的复杂度在排好序的情况下减少到 log(n)。
典型问题：开方，旋转数组查找数字



### 4. 搜索

1. 深度优先搜索
   + 核心思想：总是对新节点调用遍历。搜索到新节点时，立即对该新节点进行遍历；先入后出栈实现，也可通过与栈等价的递归；（在实际工程上，直接使用栈可能才是最好的选择，一是因为便于理解，二是更不易出现递归栈满的情况）
   + 状态记录或记忆化（回溯法）： 对已经搜索过的节点进行标记，以防止在遍历时重复搜索某个节点；需要记录节点状态的深度优先搜索；一是按引用传状态，二是所有的状态修改在递归完成后回改。
   + 典型问题：检测环路、最大的岛屿面积、朋友圈个数、数组的所有排列方式
2. 广度优先搜索
   + 需要用先入先出的队列。用栈实现的深度优先搜索和用队列实现的广度优先搜索在写法上并没有太大差异；
   + 典型问题：最短路径，岛屿间的最短距离，词梯子



### 5. 动态规划

+ 基于前提：最优子结构的意思是局部最优解能决定全局最优解，问题能够分解成子问题来解决;

+ 和带有状态记录优先搜索的区别： 动态规划是自下而上的，即先解决子问题，再解决父问题；而用带有状态记录的优先搜索是自上而下的，即从父问题搜索到子问题，若重复搜索到同一个子问题则进行状态记录，防止重复计算。如果题目需求的是最终状态，那么使用动态搜索比较方便；如果题目需要输出所有的路径，那么使用带有状态记录的优先搜索会比较方便;

+ 核心思想：在查找有很多重叠子问题的情况的最优解时有效。保存子问题的解，避免重复计算，从简单的问题直到整个问题都被解决。解决动态规划问题的关键是找到状态转移方程;

+ 典型问题：

  + 一维数组：上台阶，打家劫舍，等差子数组数量

  + 二维矩阵：最优路径数字和，每个位置到最近 0 的距离，最大正方形面积

  + 分割：完全平方数分割，字符串解码，字符串分割

  + 子序列：最长递增子序列，最长公共子序列

  + 背包：0-1 背包，完全背包，硬币组合

  + 字符串编辑：词梯子，字符串复制延展，正则匹配

  + 股票交易

    

### 6. 分治法

+ 包含三步：分解、解决、合并。通过将一个复杂的问题分解成多个相似的子问题，递归地解决这些子问题，最后合并子问题的结果来解决原问题。适用于各种复杂问题，如排序算法（快速排序、归并排序）、大整数乘法、图算法等 。
+ 自上而下的分治可以和 memoization 结合，避免重复遍历相同的子问题。如果方便推导，也可以换用自下而上的动态规划方法求解。
+ 典型问题：括号表达式结果



### 7. 位运算

+ 常用的位运算符号包括：“∧”按位异或、“&”按位与、“|”按位或、“∼”取反、“<<” 算术左移和“>>”算术右移。
+ 左移：将二进制数的所有位向左移动一定位数，低位补0，高位溢出丢弃。逻辑左移和算数左移效果相同（因为算数左移后，符号位不再参与运算)
+ 右移：算数右移适用于有符号数，根据符号位补1或补0，保留原符号位的值。符号位为0表示正数。
+ 典型应用（二进制）：
  + 去除最低位的1： n & (n - 1) 可以去除  n 表示中最低位的1。例如，n = 10100，n - 1 = 10011，n & (n - 1) = 10000；
  + 获取最低位的1： n & (-n)  可以直接获取 n 的表示中最低位的1。例如，n = 10100，-n = 01100，n & (-n) = 00100；
  + 判断一个数是否是2的幂： 如果一个数 n 是2的幂，那么 n & (n - 1) == 0。例如，n = 8（二进制为1000），n - 1 = 7（二进制为0111），n & (n - 1) = 0。这种方法可以快速判断一个数是否是2的幂；
  + 快速乘除2的幂：将一个数左移或右移相应的位数，可以实现乘以或除以2的幂次。例如，a << 1 相当于 a * 2，a >> 1 相当于 a / 2
  + 交换两个数： 使用异或运算可以在不使用临时变量的情况下交换两个数：a = a ^ b;b = a ^ b;a = a ^ b;
  + x ∧ x = 0； x ∧ 0 = x；
+ 典型问题：汉明距离，二进制下的翻转结果，单次出现的数字,0 到 *n* 的的二进制表达中分别有多少1



### 8. 数据结构

+ 数组：矩阵旋转，增序矩阵搜索值，分割增序后整体增序
+ 栈和队列：用栈实现队列，用队列实现栈，有效的括号
  + 单调栈：更暖和的一天
  + 优先队列：优先队列(堆)：合并K个增序链表，建筑物轮廓（天际线）的拐点
  + 双端队列：滑窗每个时刻包含的最大值

+ 哈希表: 根据和求两数位置，最长连续序列

+ 多重集合和映射:起止机场
+ 字符串: KMP算法



### 9. 链表

典型问题：翻转链表（递归、非递归）、合并增序链表、相邻节点交换、判断链表是否相交、是否回文



### 10. 树

+ 树的递归：与深度优先搜索的递归写法相同。是否平衡树、是否对称、节点间的无向距离、节点和等于定值、删除节点后剩余的子树;
+ 层次遍历：使用广度优先搜索进行层次遍历。每一层节点数的平均值。
+ 前中后序遍历:三种利用深度优先搜索遍历二叉树的方式: 给定前序中序遍历求二叉树
+ 二叉查找树：复原二叉查找树
+ 字典树：字典树的实现



### 11. 数学问题

+ 公倍数与公因数
+ 质数
+ 进制转换
+ 阶乘结果(找规律)
+ 字符串相加
+ 是否3的次方
+ 随机与取样
+ 单向链表随机取数

 

### 12. 排序算法

常见的排序算法：

| 类别 | 排序算法  | 命名原因                                   | 时间复杂度                                   | 空间复杂度 | 优势                           | 劣势                   | 适用情况               |
| ---- | --------- | ------------------------------------------ | -------------------------------------------- | ---------- | ------------------------------ | ---------------------- | ---------------------- |
| 插入 | 插入排序  | 按插入元素的方式命名                       | 最坏：O(n^2)  最好：O(n) 平均：O(n^2)        | O(1)       | 简单易实现，适合小规模数据     | 效率低，特别是大数据时 | 小数据量或近乎有序数据 |
| 插入 | Shell排序 | 不断分组，分别插排，最终进行一次完全的插排 | 最坏：O(n^2) 最好：O(nlogn) 平均：O(n^1.5)   | O(1)       | 对于中等规模数据较快，适用性强 | 难以优化和实现         | 中等规模数据           |
| 选择 | 选择排序  | 选择最小/最大值进行排序                    | O(n^2)                                       | O(1)       | 简单，内存要求低               | 效率低，特别是大数据时 | 小数据量               |
| 选择 | 堆排序    | 基于堆数据结构命名                         | 最坏：O(nlogn) 最好：O(nlogn) 平均：O(nlogn) | O(1)       | 不受数据分布影响，效率稳定     | 实现较复杂             | 大数据量               |
| 交换 | 冒泡排序  | 按冒泡过程命名                             | 最坏：O(n^2) 最好：O(n) 平均：O(n^2)         | O(1)       | 简单易实现，代码量少           | 效率低，特别是大数据时 | 小数据量               |
| 交换 | 快速排序  | 速度快，基于分治法                         | 最坏：O(n^2) 最好：O(nlogn) 平均：O(nlogn)   | O(logn)    | 平均性能好，适合大数据         | 最坏情况效率低         | 大数据量且随机分布     |
| 归并 | 归并排序  | 基于归并操作命名                           | 最坏：O(nlogn) 最好：O(nlogn) 平均：O(nlogn) | O(n)       | 稳定性好，适合大数据           | 内存需求大             | 大数据量               |

```python
#插入排序
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

#Shell排序
def shell_sort(arr):
    n = len(arr)
    gap = n // 2
    while gap > 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= 1
            arr[j] = temp
        gap //= 2
    return arr

#选择排序
def selection_sort(arr):
    for i in range(len(arr)):
        min_idx = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

#堆排序
def heapify(arr, n, i):
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2

    if l < n and arr[l] > arr[largest]:
        largest = l

    if r < n and arr[r] > arr[largest]:
        largest = r

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
    return arr

##冒泡排序
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

#快速排序
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

#归并排序
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < left.length and j < right.length:
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```
